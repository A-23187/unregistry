#!/usr/bin/env bash
set -euo pipefail

# Return metadata expected by the Docker CLI plugin framework: https://github.com/docker/cli/pull/1564
# TODO: update ShortDescription and Version as needed.
if [ "${1:-}" = "docker-cli-plugin-metadata" ]; then
    cat <<EOF
{
  "SchemaVersion": "0.1.0",
  "Vendor": "https://github.com/psviderski",
  "Version": "0.1.0",
  "ShortDescription": "Push Docker images to remote daemons via SSH using unregistry"
}
EOF
    exit 0
fi

# SSH command arguments to be used for all ssh commands after establishing a shared "master" connection
# using establish_ssh_connection.
declare -a SSH_ARGS=()
# sudo prefix for remote docker commands.
REMOTE_SUDO=""

# Colors for output.
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # no color

info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

# Establish SSH connection to the remote server that will be reused by subsequent ssh commands via the control socket.
# It populates the SSH_ARGS array with arguments for reuse.
establish_ssh_connection() {
    local ssh_addr="$1"
    local ssh_opts=(
        -o ControlMaster=auto
        # Unique control socket path for this invocation.
        -o "ControlPath=/tmp/docker-pussh-$$.sock"
        # The connection will be automatically terminated after 1 minute of inactivity.
        -o ControlPersist=1m
        -o ConnectTimeout=15
    )
    # Add SSH key option if provided.
    if [ -n "$SSH_KEY" ]; then
        ssh_opts+=(-i "$SSH_KEY")
    fi

    # Establish ControlMaster connection in the background.
    if ! ssh "${ssh_opts[@]}" -f -N "$ssh_addr"; then
        error "failed to connect to remote host via SSH: $ssh_addr"
    fi

    # Populate SSH_ARGS array for reuse in all subsequent commands.
    SSH_ARGS=("${ssh_opts[@]}")
    SSH_ARGS+=("$ssh_addr")
}

# Check if the remote host has Docker installed and if we can run docker commands.
# If sudo is required, it sets the REMOTE_SUDO variable to "sudo".
check_remote_docker() {
    # Check if docker command is available.
    if ! ssh "${SSH_ARGS[@]}" "command -v docker" >/dev/null 2>&1; then
        error "'docker' command not found on remote host. Please ensure Docker is installed."
    fi
    # Check if we need sudo to run docker commands.
    if ! ssh "${SSH_ARGS[@]}" "docker version" >/dev/null 2>&1; then
        # Check if we're not root and if sudo docker works.
        if ssh "${SSH_ARGS[@]}" "[ \$(id -u) -ne 0 ] && sudo docker version" >/dev/null; then
            REMOTE_SUDO="sudo"
        else
            error "failed to run docker commands on remote host. Please ensure:
  - Docker is installed and running on the remote host
  - SSH user has permissions to run docker commands (user is root or non-root user is in 'docker' group)
  - If sudo is required, ensure the user can run 'sudo docker' without a password prompt"
        fi
    fi
}

# Generate a random port in range 55000-65535.
random_port() {
    echo $((55000 + RANDOM % 10536))
}

# Check if the local Docker server is Docker Desktop.
is_docker_desktop() {
    # Read all output to a variable to avoid issues with pipefail when 'grep -q' exits early.
    local output
    output=$(docker version 2>/dev/null)
    echo "$output" | grep -q "Docker Desktop" && return 0
    return 1
}

usage() {
    echo "Usage: docker pussh [OPTIONS] IMAGE[:TAG] [USER@]HOST[:PORT]"
    echo ""
    echo "Upload a Docker image to a remote Docker daemon via SSH."
    echo ""
    echo "Options:"
    echo "  -h, --help              Show this help message."
    echo "  -i, --ssh-key path      Path to SSH private key for remote login (if not already added to SSH agent)."
    echo "      --platform string   Push a specific platform for a multi-platform image (e.g., linux/amd64, linux/arm64)."
    echo "                          Local Docker has to use containerd image store to support multi-platform images."
    echo ""
    echo "Examples:"
    echo "  docker pussh myimage:latest user@host"
    echo "  docker pussh --platform linux/amd64 myimage:latest host"
    echo "  docker pussh myimage:latest user@host:2222 -i ~/.ssh/id_ed25519"
}

DOCKER_PLATFORM=""
SSH_KEY=""
IMAGE=""
SSH_ADDRESS=""

# Skip 'pussh' if called as Docker CLI plugin.
if [ "${1:-}" = "pussh" ]; then
    shift
fi

# Parse options and arguments.
help_command="Run 'docker pussh --help' for usage information."
while [ $# -gt 0 ]; do
    case "$1" in
        -i|--ssh-key)
            if [ -z "${2:-}" ]; then
                error "-i/--ssh-key option requires an argument.\n$help_command"
            fi
            SSH_KEY="$2"
            shift 2
            ;;
        --platform)
            if [ -z "${2:-}" ]; then
                error "--platform option requires an argument.\n$help_command"
            fi
            DOCKER_PLATFORM="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            error "unknown option: $1\n$help_command"
            ;;
        *)
            # First non-option argument is the image.
            if [ -z "$IMAGE" ]; then
                IMAGE="$1"
            # Second non-option argument is the SSH address.
            elif [ -z "$SSH_ADDRESS" ]; then
                SSH_ADDRESS="$1"
            else
                error "too many arguments.\n$help_command"
            fi
            shift
            ;;
    esac
done

# Validate required arguments.
if [ -z "$IMAGE" ] || [ -z "$SSH_ADDRESS" ]; then
    error "IMAGE and HOST are required.\n$help_command"
fi
# Validate SSH key file exists if provided.
if [ -n "$SSH_KEY" ] && [ ! -f "$SSH_KEY" ]; then
    error "SSH key file not found: $SSH_KEY"
fi


# Function to cleanup resources
# TODO: review cleanup
cleanup() {
    local exit_code=$?

    if [ $exit_code -ne 0 ]; then
        warning "Cleaning up after error..."
    fi

    # Remove Docker Desktop tunnel container if exists
    if [ -n "${TUNNEL_CONTAINER:-}" ]; then
        info "Removing tunnel container..."
        docker rm -f "$TUNNEL_CONTAINER" >/dev/null 2>&1 || true
    fi

    # Stop and remove remote unregistry container
    if [ -n "${UNREGISTRY_CONTAINER:-}" ] && [ -n "${SSH_ADDRESS:-}" ]; then
        info "Stopping remote unregistry container..."
        ssh "${SSH_ARGS[@]}" "$REMOTE_SUDO docker rm -f $UNREGISTRY_CONTAINER" >/dev/null 2>&1 || true
    fi

    # Clean up local tags
    if [ -n "${LOCAL_TAG:-}" ]; then
        info "Removing local temporary tag..."
        docker rmi "$LOCAL_TAG" >/dev/null 2>&1 || true
    fi

    # Clean up remote tags if push was successful
    if [ -n "${REMOTE_TEMP_TAG:-}" ] && [ -n "${SSH_ADDRESS:-}" ] && [ "${PUSH_SUCCESS:-false}" = "true" ]; then
        info "Removing remote temporary tag..."
        ssh "${SSH_ARGS[@]}" "$REMOTE_SUDO rmi $REMOTE_TEMP_TAG" >/dev/null 2>&1 || true
    fi

    # Terminate the shared SSH connection if it was established.
    if [ ${#SSH_ARGS[@]} -ne 0 ]; then
        ssh "${SSH_ARGS[@]}" -O exit 2>/dev/null || true
    fi
}
trap cleanup INT TERM EXIT

info "Connecting to $SSH_ADDRESS..."
establish_ssh_connection "$SSH_ADDRESS"

check_remote_docker
